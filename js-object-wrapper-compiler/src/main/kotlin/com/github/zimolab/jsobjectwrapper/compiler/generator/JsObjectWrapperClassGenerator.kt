package com.github.zimolab.jsobjectwrapper.compiler.generator

import com.github.zimolab.jsobjectwrapper.compiler.debug
import com.github.zimolab.jsobjectwrapper.compiler.error
import com.github.zimolab.jsobjectwrapper.compiler.resolver.ResolvedJsObjectWrapperClass
import com.github.zimolab.jsobjectwrapper.compiler.JsObjectWrapperProcessor
import com.github.zimolab.jsobjectwrapper.compiler.asTypeName
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.TypeSpec
import java.io.OutputStream
import java.nio.charset.Charset
import java.time.LocalDateTime
import java.util.logging.Logger

class JsObjectWrapperClassGenerator(
    val options: Map<String, String>,
    val codeGenerator: CodeGenerator,
    val logger: Logger
) {

    companion object {
        const val KEY_ENCODING = "output_file_encoding"
        val CLASS_FILE_COMMENT = "" +
                "This file is automatically generated by ${JsObjectWrapperProcessor::class.simpleName}." +
                "Any changes to it may be lost.\n" +
                "DO NOT MODIFY IT MANUALLY!!!\n" +
                "Generate at ${LocalDateTime.now()}"
    }

    fun submit(resolvedClass: ResolvedJsObjectWrapperClass) {
        FileGenerateTask(resolvedClass).execute()
    }

    inner class FileGenerateTask(private val resolvedClass: ResolvedJsObjectWrapperClass) {
        fun execute() {
            logger.debug("开始生成文件(class ${resolvedClass.meta.outputClassName}@${resolvedClass.meta.outputFilename}.kt)")
            // 依赖
            val dependencies = resolvedClass.containingFile?.let {
                Dependencies(aggregating = true, it)
            }?: Dependencies(aggregating = true)
            // 输出流
            val outputStream: OutputStream = codeGenerator.createNewFile(
                fileName = resolvedClass.meta.outputFilename,
                packageName = resolvedClass.packageName,
                dependencies = dependencies
            )
            write2File(createClassFileSpec(), outputStream)
            logger.debug("文件生成完毕")
        }

        fun write2File(fileSpec: FileSpec, outputStream: OutputStream) {
            val outputFileEncoding = try {
                if (KEY_ENCODING in options) {
                    Charset.forName(options[KEY_ENCODING]!!)
                } else {
                    Charset.forName(resolvedClass.meta.outputFileEncoding)
                }
            } catch (e: Throwable) {
                logger.warning("ksp配置项或注解中指定的编码字符集不合法，将使用缺省编码(${Charset.defaultCharset()})")
                logger.error(e, throws = false)
                Charset.defaultCharset()
            }
            outputStream.bufferedWriter(outputFileEncoding).use {
                try {
                    fileSpec.writeTo(it)
                } catch (e: Throwable) {
                    logger.error(e)
                } finally {
                    it.flush()
                    it.close()
                }
            }
        }

        private fun createClassFileSpec(): FileSpec {
            return FileSpec
                .builder(resolvedClass.packageName, resolvedClass.meta.outputFilename)
                .addComment(CLASS_FILE_COMMENT)
                .addType(createClassSpec())
                .build()
        }

        private fun createClassSpec(): TypeSpec {
            val className = resolvedClass.meta.outputClassName
            val packageName = resolvedClass.packageName
            val companionObjectBuilder = TypeSpec.companionObjectBuilder()
            val clazz = ClassName(packageName, className)
            val kdoc = resolvedClass.classComment.ifEmpty { null }

            val classBuilder = TypeSpec
                .classBuilder(clazz)
                .addModifiers(KModifier.ABSTRACT)
            // 添加注释
            kdoc?.let { classBuilder.addKdoc(it) }
            // 添加超类（接口）
            classBuilder.addSuperinterface(resolvedClass.ksType.asTypeName())
            // 创建构造函数
            createConstructor(classBuilder)
            // 创建成员函数
            createFunctions(classBuilder)
            // 创建成员属性
            createProperties(classBuilder)
            // 创建companion成员
            createCompanionObjec(classBuilder, companionObjectBuilder)
            classBuilder.addType(companionObjectBuilder.build())
            return classBuilder.build()
        }

        private fun createCompanionObjec(classBuilder: TypeSpec.Builder, companionObjectBuilder: TypeSpec.Builder) {

        }

        private fun createProperties(classBuilder: TypeSpec.Builder) {

        }

        private fun createFunctions(classBuilder: TypeSpec.Builder) {

        }

        private fun createConstructor(classBuilder: TypeSpec.Builder) {

        }
    }
}