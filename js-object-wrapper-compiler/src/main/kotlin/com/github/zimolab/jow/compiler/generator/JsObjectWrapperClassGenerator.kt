package com.github.zimolab.jow.compiler.generator

import com.github.zimolab.jow.annotation.obj.JsObjectClass
import com.github.zimolab.jow.array.JsObjectWrapper
import com.github.zimolab.jow.compiler.*
import com.github.zimolab.jow.compiler.resolve.ResolvedClass
import com.github.zimolab.jow.compiler.resolve.ResolvedFunction
import com.github.zimolab.jow.compiler.resolve.ResolvedProperty
import com.github.zimolab.jow.compiler.utils.TypeUtils
import com.github.zimolab.jsarray.base.JsArrayInterface
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.squareup.kotlinpoet.*
import netscape.javascript.JSObject
import org.kotlin.formatter.KotlinFormatter
import java.io.OutputStream
import java.nio.charset.Charset
import java.time.LocalDateTime
import java.util.logging.Logger

@ExperimentalUnsignedTypes
class JsObjectWrapperClassGenerator(
    val options: Map<String, String>,
    val codeGenerator: CodeGenerator,
    val logger: Logger
) {

    companion object {
        const val KEY_ENCODING = "output_file_encoding"
        val CLASS_FILE_COMMENT = "" +
                "This file is automatically generated by ${JsObjectWrapperProcessor::class.simpleName}." +
                "Any changes to it may be lost.\n" +
                "DO NOT MODIFY IT MANUALLY!!!\n" +
                "Generate at ${LocalDateTime.now()}"
        val CodeFormatter = KotlinFormatter()

        val WARNING_SUPPRESS_FOR_CLASS = listOf(
            "FunctionName", "RedundantVisibilityModifier", "RemoveRedundantQualifierName", "RedundantUnitReturnType",
            "UNUSED_VARIABLE", "RedundantUnitExpression", "TrailingComma"
        )

    }

    fun submit(resolvedClass: ResolvedClass) {
        FileGenerateTask(resolvedClass).execute()
    }

    @ExperimentalUnsignedTypes
    private object FunctionArgumentsResolver {
        fun resolve(arguments: List<ResolvedFunction.FunctionParameter>): MutableList<String> {
            val argumentList = mutableListOf<String>()
            arguments.forEach { arg ->
                argumentList.add(resolveArgument(arg))
            }
            return argumentList
        }

        private fun resolveArgument(argument: ResolvedFunction.FunctionParameter): String {
            return if (argument.isVarargs)
                resolveVarargs(argument)
            else
                resolveNormalArg(argument)
        }

        private fun resolveVarargs(argument: ResolvedFunction.FunctionParameter): String {
            val mapPart = if (TypeUtils.isJsObjectWrapperType(argument.type)) {
                "_${resolveJsObjectWrapperArg(argument)}"

            } else if (TypeUtils.isJsArrayInterfaceType(argument.type)) {
                "_${resolveJsArrayArg(argument)}"
            } else {
                null
            }
            val arg = argument.name
            return when (mapPart) {
                null -> {
                    if (TypeUtils.hasToTypedArrayFunction(argument.type)) {
                        "*(${arg}.toTypedArray())"
                    } else {
                        "*(${arg})"
                    }
                }
                else -> {
                    "*(${arg}.map{_${arg}-> $mapPart }.toTypedArray())"
                }
            }
        }

        private fun resolveNormalArg(argument: ResolvedFunction.FunctionParameter): String {
            return if (TypeUtils.isJsObjectWrapperType(argument.type)) {
                resolveJsObjectWrapperArg(argument)
            } else if (TypeUtils.isJsArrayInterfaceType(argument.type)) {
                resolveJsArrayArg(argument)
            } else {
                argument.name
            }

        }

        private fun resolveJsObjectWrapperArg(argument: ResolvedFunction.FunctionParameter): String {
            return if (TypeUtils.isNullable(argument.type))
                "${argument.name}?.${JsObjectWrapper::source.name}"
            else
                "${argument.name}.${JsObjectWrapper::source.name}"
        }

        private fun resolveJsArrayArg(argument: ResolvedFunction.FunctionParameter): String {
            return if (TypeUtils.isNullable(argument.type))
                "${argument.name}?.${JsArrayInterface<*>::reference.name}"
            else
                "${argument.name}.${JsArrayInterface<*>::reference.name}"
        }

    }

    inner class FileGenerateTask(private val resolvedClass: ResolvedClass) {

        fun execute() {
            logger.debug("开始生成文件(class ${resolvedClass.meta.outputClassName}@${resolvedClass.meta.outputFilename}.kt)")
            // 依赖
            val dependencies = resolvedClass.containingFile?.let {
                Dependencies(aggregating = true, it)
            } ?: Dependencies(aggregating = true)
            // 输出流
            val outputStream: OutputStream = codeGenerator.createNewFile(
                fileName = resolvedClass.meta.outputFilename,
                packageName = resolvedClass.packageName,
                dependencies = dependencies
            )
            write2File(createClassFileSpec(), outputStream)
            logger.debug("文件生成完毕")
        }

        private fun write2File(fileSpec: FileSpec, outputStream: OutputStream) {
            val outputFileEncoding = try {
                if (KEY_ENCODING in options) {
                    Charset.forName(options[KEY_ENCODING]!!)
                } else {
                    logger.debug("输出文件编码字符集：${resolvedClass.meta.outputFileEncoding}")
                    Charset.forName(resolvedClass.meta.outputFileEncoding)
                }
            } catch (e: Throwable) {
                logger.warning("ksp配置项或注解中指定的编码字符集不合法，将使用缺省编码(${Charset.defaultCharset()})")
                logger.error(e, throws = false)
                Charset.defaultCharset()
            }
            outputStream.bufferedWriter(outputFileEncoding).use {
                try {
                    fileSpec.writeTo(it)
                } catch (e: Throwable) {
                    logger.error(e)
                } finally {
                    it.flush()
                    it.close()
                }
            }
        }

        private fun createClassFileSpec(): FileSpec {
            return FileSpec
                .builder(resolvedClass.packageName, resolvedClass.meta.outputFilename)
                .addComment(CLASS_FILE_COMMENT)
                .addType(createClassSpec())
                .build()
        }

        private fun createClassSpec(): TypeSpec {
            val className = resolvedClass.meta.outputClassName
            val packageName = resolvedClass.packageName
            val companionObjectBuilder = TypeSpec.companionObjectBuilder()
            val clazz = ClassName(packageName, className)
            val kdoc = resolvedClass.classComment.ifEmpty { null }

            val classBuilder = TypeSpec
                .classBuilder(clazz)
                .addModifiers(KModifier.ABSTRACT)
            // 添加注释
            kdoc?.let { classBuilder.addKdoc(it) }
            // 添加超类（接口）
            classBuilder.addSuperinterface(resolvedClass.ksType.asTypeName())
            // 添加一些注解
            createClassAnnotations(classBuilder)
            // 创建构造函数
            createConstructor(classBuilder)
            // 创建成员函数
            createFunctions(classBuilder)
            // 创建成员属性
            createProperties(classBuilder)
            classBuilder.addType(companionObjectBuilder.build())
            return classBuilder.build()
        }

        private fun createClassAnnotations(classBuilder: TypeSpec.Builder) {
            // 添加@Suppress，抑制一些警告信息
            val warnSuppressAnnotation =
                AnnotationSpec.builder(Suppress::class).apply {
                    WARNING_SUPPRESS_FOR_CLASS.forEach {suppress-> addMember("%S", suppress) }
                }.build()
            classBuilder.addAnnotation(warnSuppressAnnotation)
        }

        // TODO
        private fun createCompanionMembers(classBuilder: TypeSpec.Builder, companionObjectBuilder: TypeSpec.Builder) {

        }

        private fun createProperties(classBuilder: TypeSpec.Builder) {
            val propSpecs =
                resolvedClass.properties.filter { !it.meta.skipped }.map { createProperty(it, classBuilder) }
            classBuilder.addProperties(propSpecs)
        }

        private fun createProperty(
            resolvedProperty: ResolvedProperty,
            classBuilder: TypeSpec.Builder
        ): PropertySpec {

            val propertyBuilder = PropertySpec.builder(resolvedProperty.simpleName, resolvedProperty.type.asTypeName())
            propertyBuilder
                .mutable(resolvedProperty.mutable)
                .addModifiers(KModifier.OVERRIDE)

            val nullable = resolvedProperty.nullable
            val undefinedAsNull = resolvedProperty.meta.undefinedAsNull
            val raiseExceptionOnUndefined = resolvedProperty.meta.raiseExceptionOnUndefined
            val isVoidType = TypeUtils.isVoidType(resolvedProperty.type)
            val isNativeType = TypeUtils.isNativeType(resolvedProperty.type)
            val isAnyType = TypeUtils.isAnyType(resolvedProperty.type)

            // getter
            val getterTypeMapper = TypeMapper.of(TypeMappingTarget.PROP_GETTER, resolvedProperty, classBuilder)
            val getterBuilder = FunSpec.getterBuilder()
            val getterCodeTemplate = """
                val ret = ${JsObjectWrapper::source.name}.getMember(%S)
            ${
                if (nullable && undefinedAsNull)
                    """
                    if(ret == null || ret == "undefined")
                        return null
                    """
                else if (nullable && !undefinedAsNull)
                    """
                    if(ret == null)
                        return null
                    """
                else
                    ""
            }
            ${
                if (!undefinedAsNull && raiseExceptionOnUndefined)
                    """
                    if(ret == "undefined")
                        throw RuntimeException("an undefined returned.")
                    return ret
                    """
                else
                    ""
            }
            ${
                if (isVoidType) {
                    "return Unit"
                } else if (isAnyType) {
                    "return ret"
                } else if (isNativeType) {
                    """
                    if(ret !is %T)
                        throw RuntimeException("the type of return value is not as expected.")
                    return  ret
                    """
                } else {
                    if (getterTypeMapper.method == TypeMappingMethod.USE_MAPPING_FUNCTION)
                        "return ${getterTypeMapper.functionName}(ret)"
                    else
                        "return ret as ${resolvedProperty.type.asTypeName().copy(nullable = false)}"
                }
            }
            """
            val getterCodeBlock = if (isNativeType) {
                CodeBlock.of(
                    getterCodeTemplate,
                    resolvedProperty.meta.jsMemberName,
                    resolvedProperty.type.asTypeName()
                )
                    .toString()
            } else {
                CodeBlock.of(getterCodeTemplate, resolvedProperty.meta.jsMemberName).toString()
            }.let {
                CodeFormatter.format(it).replace(" ", "·")
            }
            getterBuilder.addCode(getterCodeBlock)
            propertyBuilder.getter(getterBuilder.build())
            //~getter

            //setter
            val setterTypeMapper = TypeMapper.of(TypeMappingTarget.PROP_SETTER, resolvedProperty, classBuilder)
            val setterParamName = "v"
            if (resolvedProperty.mutable) {
                val setterBuilder = FunSpec.setterBuilder()
                val setterCodeTemplate = if (setterTypeMapper.method == TypeMappingMethod.USE_MAPPING_FUNCTION) {
                    """
                    ${JsObjectWrapper::source.name}.setMember(%S, ${setterTypeMapper.functionName}($setterParamName))
                    """
                } else {
                    """${JsObjectWrapper::source.name}.setMember(%S, $setterParamName)"""
                }.replace(" ", "·")
                val setterCodeBlock =
                    CodeBlock.of(setterCodeTemplate, resolvedProperty.meta.jsMemberName)
                        .toString().let {
                            CodeFormatter.format(it).replace(" ", "·")
                        }
                setterBuilder
                    .addParameter(setterParamName, resolvedProperty.type.asTypeName())
                    .addCode(setterCodeBlock)
                propertyBuilder.setter(setterBuilder.build())
            }
            //~setter
            return propertyBuilder.build()
        }

        private fun createFunctions(classBuilder: TypeSpec.Builder) {
            val funSpecs = resolvedClass.functions.filter { !it.meta.skipped }.map { createFunction(it, classBuilder) }
            classBuilder.addFunctions(funSpecs)
        }

        private fun createConstructor(classBuilder: TypeSpec.Builder) {
            when (resolvedClass.meta.primaryConstructor) {
                // 不生成主构造函数
                JsObjectClass.PrimaryConstructor.None -> return
                // 生成空的主构造函数
                JsObjectClass.PrimaryConstructor.Blank -> {
                    val primaryConstructor = FunSpec.constructorBuilder()
                        .build()
                    classBuilder
                        .primaryConstructor(primaryConstructor)
                }
                // 生成带属性和参数的主构造函数
                // 目前可以带的参数只有一个，即来自JsObjectWrapper的source属性
                JsObjectClass.PrimaryConstructor.WithParameter -> {
                    val primaryConstructor = FunSpec.constructorBuilder()
                        .addParameter(JsObjectWrapper::source.name, JSObject::class)
                        .build()
                    classBuilder
                        .primaryConstructor(primaryConstructor)
                        .addProperty(
                            PropertySpec
                                .builder(JsObjectWrapper::source.name, JSObject::class)
                                .addModifiers(KModifier.OVERRIDE)
                                .initializer(JsObjectWrapper::source.name)
                                .build()
                        )
                }
                else -> {
                    AnnotationProcessingError("不支持的主构造函数类型（${resolvedClass.meta.primaryConstructor}）").let {
                        logger.error(it)
                    }
                }
            }
        }

        private fun createFunction(
            resolvedFunction: ResolvedFunction,
            classBuilder: TypeSpec.Builder
        ): FunSpec {
            val functionName = resolvedFunction.simpleName
            val jsMemberName = resolvedFunction.meta.jsMemberName
            val parameters = resolvedFunction.parameters
            val functionReturnType = resolvedFunction.returnType
            val raiseExceptionOnUndefined = resolvedFunction.meta.raiseExceptionOnUndefined

            val functionBuilder = FunSpec
                .builder(functionName)
                .addModifiers(KModifier.OVERRIDE)
                .returns(functionReturnType.asTypeName())

            // 添加函数参数（形式参数）
            parameters.forEach { param ->
                val paramSpec = if (param.isVararg) {
                    ParameterSpec.builder(param.name, param.type.asTypeName(), KModifier.VARARG).build()
                } else {
                    ParameterSpec.builder(param.name, param.type.asTypeName()).build()
                }
                functionBuilder.addParameter(paramSpec)
            }

            // 底层调用call()函数所需的参数列表（实参）
            // 包括了可自定义的类型转换处理、支持vararg参数等特性
            val argumentList = mutableListOf<String>()
            parameters.forEach { param->
                val paramTypeMapper = TypeMapper.of(TypeMappingTarget.FUNC_PARAMETER, param, classBuilder)
                argumentList.add(param.meta.asArgumentString(paramTypeMapper))
            }

            // 添加函数体
            val nullable = TypeUtils.isNullable(functionReturnType)
            val isNativeType = TypeUtils.isNativeType(functionReturnType)
            val isVoidType = TypeUtils.isVoidType(functionReturnType)
            val isAnyType = TypeUtils.isAnyType(functionReturnType)
            val undefinedAsNull = resolvedFunction.meta.undefinedAsNull

            // 如果返回值不是支持直接转换的原生类型，则需要添加一个额外的类型转换函数（模板方法），用来对返回值进行转换
            val returnTypeMapper = TypeMapper.of(TypeMappingTarget.FUNC_RETURN, resolvedFunction, classBuilder)
            val returnTypeMappingFunc = returnTypeMapper.functionName

            val codeTemplate = """
                val ret = ${JsObjectWrapper::source.name}.call(%S, %L)
            ${
                if (nullable && undefinedAsNull)
                    "if(ret == null || ret == \"undefined\")\n" +
                            "return null"
                else if (nullable && !undefinedAsNull)
                    "if(ret == null)\n" +
                            "return null"
                else
                    ""
            }
            ${
                if (!undefinedAsNull && raiseExceptionOnUndefined)
                    "if(ret == \"undefined\") \n" +
                            "throw RuntimeException(\"an undefined returned.\")"
                else
                    ""
            }
            ${
                if (isVoidType)
                    "return Unit"
                else if (isAnyType)
                    "return ret"
                else if (isNativeType)
                    "if(ret !is %T)\n throw RuntimeException(\"the type of return value is not as expected.\")\n" +
                            "return ret"
                else
                    "return ${returnTypeMappingFunc}(ret)"
            }
            """

            val codeBlock = if (isNativeType) {
                CodeBlock.of(
                    codeTemplate,
                    jsMemberName,
                    argumentList.joinToString(","),
                    functionReturnType.asTypeName().copy(nullable = false)
                ).toString()
            } else {
                CodeBlock.of(
                    codeTemplate,
                    jsMemberName,
                    argumentList.joinToString(","),
                ).toString()
            }.let {
                CodeFormatter.format(it)
            }
            functionBuilder.addCode(codeBlock.replace(" ", "·"))
            return functionBuilder.build()
        }

    }
}