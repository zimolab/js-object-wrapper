package com.github.zimolab.jow.compiler.generator

import com.github.zimolab.jow.annotation.obj.JsObjectWrapperClass
import com.github.zimolab.jow.compiler.resolver.ResolvedJsObjectWrapperClass
import com.github.zimolab.jow.compiler.resolver.ResolvedJsObjectWrapperFunction
import com.github.zimolab.jow.array.JsObjectWrapper
import com.github.zimolab.jow.compiler.*
import com.github.zimolab.jow.compiler.asTypeName
import com.github.zimolab.jow.compiler.TypeUtils
import com.github.zimolab.jow.compiler.resolver.ResolvedJsObjectWrapperProperty
import com.github.zimolab.jsarray.base.JsArrayInterface
import com.google.devtools.ksp.processing.CodeGenerator
import com.google.devtools.ksp.processing.Dependencies
import com.google.devtools.ksp.symbol.KSType
import com.squareup.kotlinpoet.*
import netscape.javascript.JSObject
import org.kotlin.formatter.KotlinFormatter
import java.io.OutputStream
import java.nio.charset.Charset
import java.time.LocalDateTime
import java.util.logging.Logger

@ExperimentalUnsignedTypes
class JsObjectWrapperClassGenerator(
    val options: Map<String, String>,
    val codeGenerator: CodeGenerator,
    val logger: Logger
) {

    companion object {
        const val KEY_ENCODING = "output_file_encoding"
        val CLASS_FILE_COMMENT = "" +
                "This file is automatically generated by ${JsObjectWrapperProcessor::class.simpleName}." +
                "Any changes to it may be lost.\n" +
                "DO NOT MODIFY IT MANUALLY!!!\n" +
                "Generate at ${LocalDateTime.now()}"
        val CodeFormatter = KotlinFormatter()

    }

    fun submit(resolvedClass: ResolvedJsObjectWrapperClass) {
        FileGenerateTask(resolvedClass).execute()
    }

    @ExperimentalUnsignedTypes
    private object FunctionArgumentsResolver {
        fun resolve(arguments: List<ResolvedJsObjectWrapperFunction.FunctionParameter>): MutableList<String> {
            val argumentList = mutableListOf<String>()
            arguments.forEach { arg ->
                argumentList.add(resolveArgument(arg))
            }
            return argumentList
        }

        private fun resolveArgument(argument: ResolvedJsObjectWrapperFunction.FunctionParameter): String {
            return if (argument.isVarargs)
                resolveVarargs(argument)
            else
                resolveNormalArg(argument)
        }

        private fun resolveVarargs(argument: ResolvedJsObjectWrapperFunction.FunctionParameter): String {
            val mapPart = if (TypeUtils.isJsObjectWrapperType(argument.type)) {
                "_${resolveJsObjectWrapperArg(argument)}"

            } else if (TypeUtils.isJsArrayInterfaceType(argument.type)) {
                "_${resolveJsArrayArg(argument)}"
            } else {
                null
            }
            val arg = argument.name
            return when (mapPart) {
                null -> {
                    val logger = Logger.getLogger(JsObjectWrapperProcessor::class.java.canonicalName)
                    logger.debug("arg type: ${argument.type}")
                    if (TypeUtils.hasToTypedArrayFunction(argument.type)) {
                        "*(${arg}.toTypedArray())"
                    } else {
                        "*(${arg})"
                    }
                }
                else -> {
                    "*(${arg}.map{_${arg}-> $mapPart }.toTypedArray())"
                }
            }
        }

        private fun resolveNormalArg(argument: ResolvedJsObjectWrapperFunction.FunctionParameter): String {
            return if (TypeUtils.isJsObjectWrapperType(argument.type)) {
                resolveJsObjectWrapperArg(argument)
            } else if (TypeUtils.isJsArrayInterfaceType(argument.type)) {
                resolveJsArrayArg(argument)
            } else {
                argument.name
            }

        }

        private fun resolveJsObjectWrapperArg(argument: ResolvedJsObjectWrapperFunction.FunctionParameter): String {
            return if (TypeUtils.isNullable(argument.type))
                "${argument.name}?.${JsObjectWrapper::source.name}"
            else
                "${argument.name}.${JsObjectWrapper::source.name}"
        }

        private fun resolveJsArrayArg(argument: ResolvedJsObjectWrapperFunction.FunctionParameter): String {
            return if (TypeUtils.isNullable(argument.type))
                "${argument.name}?.${JsArrayInterface<*>::reference.name}"
            else
                "${argument.name}.${JsArrayInterface<*>::reference.name}"
        }

    }

    inner class FileGenerateTask(private val resolvedClass: ResolvedJsObjectWrapperClass) {


        fun execute() {
            logger.debug("开始生成文件(class ${resolvedClass.meta.outputClassName}@${resolvedClass.meta.outputFilename}.kt)")
            // 依赖
            val dependencies = resolvedClass.containingFile?.let {
                Dependencies(aggregating = true, it)
            } ?: Dependencies(aggregating = true)
            // 输出流
            val outputStream: OutputStream = codeGenerator.createNewFile(
                fileName = resolvedClass.meta.outputFilename,
                packageName = resolvedClass.packageName,
                dependencies = dependencies
            )
            write2File(createClassFileSpec(), outputStream)
            logger.debug("文件生成完毕")
        }

        private fun write2File(fileSpec: FileSpec, outputStream: OutputStream) {
            val outputFileEncoding = try {
                if (KEY_ENCODING in options) {
                    Charset.forName(options[KEY_ENCODING]!!)
                } else {
                    logger.debug("输出文件编码字符集：${resolvedClass.meta.outputFileEncoding}")
                    Charset.forName(resolvedClass.meta.outputFileEncoding)
                }
            } catch (e: Throwable) {
                logger.warning("ksp配置项或注解中指定的编码字符集不合法，将使用缺省编码(${Charset.defaultCharset()})")
                logger.error(e, throws = false)
                Charset.defaultCharset()
            }
            outputStream.bufferedWriter(outputFileEncoding).use {
                try {
                    fileSpec.writeTo(it)
                } catch (e: Throwable) {
                    logger.error(e)
                } finally {
                    it.flush()
                    it.close()
                }
            }
        }

        private fun createClassFileSpec(): FileSpec {
            return FileSpec
                .builder(resolvedClass.packageName, resolvedClass.meta.outputFilename)
                .addComment(CLASS_FILE_COMMENT)
                .addType(createClassSpec())
                .build()
        }

        private fun createClassSpec(): TypeSpec {
            val className = resolvedClass.meta.outputClassName
            val packageName = resolvedClass.packageName
            val companionObjectBuilder = TypeSpec.companionObjectBuilder()
            val clazz = ClassName(packageName, className)
            val kdoc = resolvedClass.classComment.ifEmpty { null }

            val classBuilder = TypeSpec
                .classBuilder(clazz)
                .addModifiers(KModifier.ABSTRACT)
            // 添加注释
            kdoc?.let { classBuilder.addKdoc(it) }
            // 添加超类（接口）
            classBuilder.addSuperinterface(resolvedClass.ksType.asTypeName())
            // 添加一些注解
            createClassAnnotations(classBuilder)
            // 创建构造函数
            createConstructor(classBuilder)
            // 创建成员函数
            createFunctions(classBuilder)
            // 创建成员属性
            createProperties(classBuilder)
            classBuilder.addType(companionObjectBuilder.build())
            return classBuilder.build()
        }

        private fun createClassAnnotations(classBuilder: TypeSpec.Builder) {
            // 添加@Suppress("FunctionName")注解，抑制函数名称
            classBuilder.addAnnotation(
                AnnotationSpec
                    .builder(Suppress::class)
                    .addMember("%S", "FunctionName")
                    .build()
            )
        }

        private fun createCompanionMembers(classBuilder: TypeSpec.Builder, companionObjectBuilder: TypeSpec.Builder) {

        }

        private fun createProperties(classBuilder: TypeSpec.Builder) {
            val propSpecs =
                resolvedClass.properties.filter { !it.meta.skipped }.map { createProperty(it, classBuilder) }
            classBuilder.addProperties(propSpecs)
        }

        private fun createProperty(
            resolvedProperty: ResolvedJsObjectWrapperProperty,
            classBuilder: TypeSpec.Builder
        ): PropertySpec {

            val propertyBuilder = PropertySpec.builder(resolvedProperty.simpleName, resolvedProperty.type.asTypeName())
            propertyBuilder
                .mutable(resolvedProperty.mutable)
                .addModifiers(KModifier.OVERRIDE)

            val nullable = resolvedProperty.nullable
            val undefinedAsNull = resolvedProperty.meta.undefinedAsNull
            val raiseExceptionOnUndefined = resolvedProperty.meta.raiseExceptionOnUndefined
            val isVoidType = TypeUtils.isVoidType(resolvedProperty.type)
            val isNativeType = TypeUtils.isNativeType(resolvedProperty.type)
            val isAnyType = TypeUtils.isAnyType(resolvedProperty.type)

            // getter
            val getterTypeCast = resolvedProperty.meta.getterTypeCast
            if (getterTypeCast.category == TypeCastMethod.CAST_FUNCTION) {
                val funcName = getterTypeCast.typeCastFunctionName
                if (classBuilder.funSpecs.firstOrNull{it.name == funcName && it.parameters.count() == 1} == null) {
                    classBuilder.addFunction(
                        TypeCast.createGetterCastFunction(funcName, "arg", resolvedProperty)
                    )
                }
            }
            val getterBuilder = FunSpec.getterBuilder()
            val getterCodeTemplate = """
                val ret = ${JsObjectWrapper::source.name}.getMember(%S)
            ${
                if (nullable && undefinedAsNull)
                    """
                    if(ret == null || ret == "undefined")
                        return null
                    """
                else if (nullable && !undefinedAsNull)
                    """
                    if(ret == null)
                        return null
                    """
                else
                    ""
            }
            ${
                if (!undefinedAsNull && raiseExceptionOnUndefined)
                    """
                    if(ret == "undefined")
                        throw RuntimeException("an undefined returned.")
                    return ret
                    """
                else
                    ""
            }
            ${
                if (isVoidType) {
                    "return Unit"
                } else if (isAnyType) {
                    "return ret"
                } else if (isNativeType) {
                    """
                    if(ret !is %T)
                        throw RuntimeException("the type of return value is not as expected.")
                    return  ret
                    """
                } else {
                    if (getterTypeCast.category == TypeCastMethod.CAST_FUNCTION)
                        "return ${getterTypeCast.typeCastFunctionName}(ret)"
                    else
                        "return ret as ${resolvedProperty.type.asTypeName().copy(nullable = false)}"
                }
            }
            """
            val getterCodeBlock = if (isNativeType) {
                CodeBlock.of(
                    getterCodeTemplate,
                    resolvedProperty.meta.jsMemberName,
                    resolvedProperty.type.asTypeName()
                )
                    .toString()
            } else {
                CodeBlock.of(getterCodeTemplate, resolvedProperty.meta.jsMemberName).toString()
            }.let {
                CodeFormatter.format(it).replace(" ", "·")
            }
            getterBuilder.addCode(getterCodeBlock)
            propertyBuilder.getter(getterBuilder.build())
            //~getter

            //setter
            val setterTypeCast = resolvedProperty.meta.setterTypeCast
            if (setterTypeCast.category == TypeCastMethod.CAST_FUNCTION) {
                val funcName = setterTypeCast.typeCastFunctionName
                val builtinFunction = setterTypeCast.builtinCastFunction
                if (builtinFunction != null) {
                    if (classBuilder.funSpecs.firstOrNull { it.name==funcName && it.parameters.count()==1 } == null) {
                        classBuilder.addFunction(builtinFunction)
                    }
                } else {
                    if (classBuilder.funSpecs.firstOrNull { it.name==funcName && it.parameters.count()==1 } == null) {
                        classBuilder.addFunction(TypeCast.createSetterCastFunction(funcName, "arg", resolvedProperty))
                    }
                }
            }
            val setterParamName = "v"
            if (resolvedProperty.mutable) {
                val setterBuilder = FunSpec.setterBuilder()
                val setterCodeTemplate = if (setterTypeCast.category == TypeCastMethod.CAST_FUNCTION) {
                    """
                    ${JsObjectWrapper::source.name}.setMember(%S, ${setterTypeCast.typeCastFunctionName}($setterParamName))
                    """
                } else {
                    """${JsObjectWrapper::source.name}.setMember(%S, $setterParamName)"""
                }.replace(" ", "·")
                val setterCodeBlock =
                    CodeBlock.of(setterCodeTemplate, resolvedProperty.meta.jsMemberName)
                        .toString().let {
                            CodeFormatter.format(it).replace(" ", "·")
                        }
                setterBuilder
                    .addParameter(setterParamName, resolvedProperty.type.asTypeName())
                    .addCode(setterCodeBlock)
                propertyBuilder.setter(setterBuilder.build())
            }
            //~setter
            return propertyBuilder.build()
        }

        private fun createTypeCastor(
            typeCastorName: String,
            argumentType: TypeName,
            returnType: TypeName,
            classBuilder: TypeSpec.Builder
        ) {
            if (classBuilder.funSpecs.firstOrNull { it.name == typeCastorName } != null)
                return
            val typeCastor = FunSpec
                .builder(typeCastorName)
                .addModifiers(KModifier.ABSTRACT)
                .addParameter("originReturn", argumentType)
                .returns(returnType)
                .build()
            classBuilder.addFunction(typeCastor)
        }

        private fun createFunctions(classBuilder: TypeSpec.Builder) {
            val funSpecs = resolvedClass.functions.filter { !it.meta.skipped }.map { createFunction(it, classBuilder) }
            classBuilder.addFunctions(funSpecs)
        }

        private fun createConstructor(classBuilder: TypeSpec.Builder) {
            when (resolvedClass.meta.primaryConstructor) {
                // 不生成主构造函数
                JsObjectWrapperClass.PrimaryConstructor.None -> return
                // 生成空的主构造函数
                JsObjectWrapperClass.PrimaryConstructor.Blank -> {
                    val primaryConstructor = FunSpec.constructorBuilder()
                        .build()
                    classBuilder
                        .primaryConstructor(primaryConstructor)
                }
                // 生成带属性和参数的主构造函数
                // 目前可以带的参数只有一个，即来自JsObjectWrapper的source属性
                JsObjectWrapperClass.PrimaryConstructor.WithParameter -> {
                    val primaryConstructor = FunSpec.constructorBuilder()
                        .addParameter(JsObjectWrapper::source.name, JSObject::class)
                        .build()
                    classBuilder
                        .primaryConstructor(primaryConstructor)
                        .addProperty(
                            PropertySpec
                                .builder(JsObjectWrapper::source.name, JSObject::class)
                                .addModifiers(KModifier.OVERRIDE)
                                .initializer(JsObjectWrapper::source.name)
                                .build()
                        )
                }
                else -> {
                    AnnotationProcessingError("不支持的主构造函数类型（${resolvedClass.meta.primaryConstructor}）").let {
                        logger.error(it)
                    }
                }
            }
        }

        private fun createFunction(
            resolvedFunction: ResolvedJsObjectWrapperFunction,
            classBuilder: TypeSpec.Builder
        ): FunSpec {
            val functionName = resolvedFunction.simpleName
            val jsMemberName = resolvedFunction.meta.jsMemberName
            val functionParameters = resolvedFunction.parameters
            val functionReturnType = resolvedFunction.returnType
            val raiseExceptionOnUndefined = resolvedFunction.meta.raiseExceptionOnUndefined

            val functionBuilder = FunSpec
                .builder(functionName)
                .addModifiers(KModifier.OVERRIDE)
                .returns(functionReturnType.asTypeName())

            // 添加函数参数
            functionParameters.forEach { param ->
                val paramSpec = if (param.isVarargs) {
                    ParameterSpec.builder(param.name, param.type.asTypeName(), KModifier.VARARG).build()
                } else {
                    ParameterSpec.builder(param.name, param.type.asTypeName()).build()
                }
                functionBuilder.addParameter(paramSpec)
            }

            // 添加函数体
            val argumentsBuffer = StringBuffer()
            FunctionArgumentsResolver.resolve(functionParameters).joinTo(argumentsBuffer)

            val nullable = TypeUtils.isNullable(functionReturnType)
            val isNativeType = TypeUtils.isNativeType(functionReturnType)
            val isVoidType = TypeUtils.isVoidType(functionReturnType)
            val isAnyType = TypeUtils.isAnyType(functionReturnType)
            val undefinedAsNull = resolvedFunction.meta.undefinedAsNull

            // 如果返回值不是支持直接转换的本地类型，则需要额外添加一个类型转换函数（模板方法），用来对返回值进行转换
            // 该类型转换函数的名称可以在注解中以returnTypeCastor参数进行指定，如果未指定名称（returnTypeCastor=“None”||returnTypeCastor=“”），
            // 则使用默认规则自动生成一个名称，名称生成规则为：__as${returnType}__
            if (!isNativeType && !isVoidType && !isAnyType) {
                if (resolvedFunction.meta.returnTypeCastor == null)
                    resolvedFunction.meta.returnTypeCastor = "__as${functionReturnType.simpleName}__"
                createReturnTypeCastor(resolvedFunction.meta.returnTypeCastor, functionReturnType, classBuilder)
            }
            val returnTypeCastor = resolvedFunction.meta.returnTypeCastor

            val codeTemplate = """
                val ret = ${JsObjectWrapper::source.name}.call(%S, %L)
            ${
                if (nullable && undefinedAsNull)
                    "if(ret == null || ret == \"undefined\")\n" +
                            "return null"
                else if (nullable && !undefinedAsNull)
                    "if(ret == null)\n" +
                            "return null"
                else
                    ""
            }
            ${
                if (!undefinedAsNull && raiseExceptionOnUndefined)
                    "if(ret == \"undefined\") \n" +
                            "throw RuntimeException(\"an undefined returned.\")"
                else
                    ""
            }
            ${
                if (isVoidType)
                    "return Unit"
                else if (isAnyType)
                    "return ret"
                else if (isNativeType)
                    "if(ret !is %T)\n throw RuntimeException(\"the type of return value is not as expected.\")\n" +
                            "return ret"
                else
                    "return ${returnTypeCastor}(ret)"
            }
            """

            val codeBlock = if (isNativeType) {
                CodeBlock.of(
                    codeTemplate,
                    jsMemberName,
                    argumentsBuffer.toString(),
                    functionReturnType.asTypeName().copy(nullable = false)
                ).toString()
            } else {
                CodeBlock.of(
                    codeTemplate,
                    jsMemberName,
                    argumentsBuffer.toString(),
                ).toString()
            }.let {
                CodeFormatter.format(it)
            }
            functionBuilder.addCode(codeBlock.replace(" ", "·"))
            return functionBuilder.build()
        }

        private fun createReturnTypeCastor(
            returnTypeCastor: String?,
            returnType: KSType,
            classBuilder: TypeSpec.Builder
        ) {
            if (returnTypeCastor == null)
                return
            val castor = classBuilder.funSpecs.firstOrNull { it.name == returnTypeCastor }
            if (castor == null) {
                val builder = FunSpec
                    .builder(returnTypeCastor)
                    .addModifiers(KModifier.ABSTRACT)
                    .returns(returnType.asTypeName())
                    .addParameter("originReturn", Any::class.asTypeName())
                classBuilder.addFunction(builder.build())
            }
        }
    }
}